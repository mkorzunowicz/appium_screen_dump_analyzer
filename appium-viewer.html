<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Universal XML‚ÄëBounds Viewer</title>
  <!-- Tailwind for styling (demo) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Screenshot always fully visible (fits height & width) */
    #screenWrapper,
    #screenshot {
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
    }

    /* Overlay boxes */
    .element-box {
      border: 2px solid rgba(16, 196, 16, 0.5);
      background: rgba(16, 196, 16, 0.01); /* 1% transparency */
      transition: background 120ms, border-color 120ms;
      pointer-events: auto;
    }
    .element-box:hover {
      border-color: rgba(0, 192, 255, 0.85);
      background: rgba(0, 192, 255, 0.10);
    }
    .selected-box {
      border-color: rgb(239 68 68) !important;
      background: rgba(239, 68, 68, 0.16) !important;
    }

    /* Tree styles */
    #treeContainer ul {
      list-style: none;
      margin: 0;
      padding: 0 0 0 0.5rem; /* indent children */
    }
    .tree-row {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      line-height: 1.25rem;
      cursor: pointer;
      white-space: nowrap;
    }
    .tree-row:hover span.label {
      color: rgb(37 99 235);
    }
    .selected-tree {
      color: rgb(239 68 68) !important;
      font-weight: 600;
    }

    /* Resizable sidebar */
    .resize-x {
      resize: horizontal;
      overflow: auto;
    }

    /* Resizable sidebar - drag handle */
    .sidebar {
      position: relative;
      background: #1a202c;
      color: #e5e7eb;
      border-right: 2px solid #222;
    }
    .sidebar-drag {
      position: absolute;
      top: 0;
      right: -5px;
      width: 12px;
      height: 100%;
      cursor: ew-resize;
      z-index: 10;
      background: rgba(59,130,246,0.18); /* brighter and easier to grab */
      border-radius: 3px;
      transition: background 120ms;
    }
    .sidebar-drag:hover {
      background: rgba(59,130,246,0.32);
    }
    /* Dark theme tweaks for sidebar */
    #sidebar h2 { color: #fff; }
    #sidebar .border { border-color: #333; }
    #sidebar .bg-white { background: #222; color: #e5e7eb; }
    #sidebar .text-xs { color: #cbd5e1; }
    #sidebar .font-mono { color: #a3e635; }
    #sidebar .rounded { border-radius: 0.375rem; }
    #sidebar .border-gray-300 { border-color: #333; }
    #sidebar .border { border-color: #333; }
    #sidebar .bg-gray-100 { background: #1a202c; }
    #sidebar .text-gray-600 { color: #a1a1aa; }
    #sidebar .text-gray-400 { color: #a1a1aa; }
    #sidebar .text-gray-500 { color: #a1a1aa; }
    #sidebar .text-green-600 { color: #22c55e; }
    #sidebar .text-red-600 { color: #ef4444; }
    #sidebar .text-blue-600 { color: #2563eb; }
    #sidebar .hover\:bg-blue-700:hover { background: #1e40af; }
    #sidebar .bg-blue-600 { background: #2563eb; }
    #sidebar .bg-blue-100 { background: #1e293b; color: #60a5fa; }
    #sidebar .hover\:bg-blue-300:hover { background: #2563eb; color: #fff; }
    /* Dark scrollbars */
    #sidebar, #treeContainer, #propTable, #propOutput, #xpathOutput {
      scrollbar-width: thin;
      scrollbar-color: #333 #222;
    }
    #sidebar::-webkit-scrollbar, #treeContainer::-webkit-scrollbar, #propTable::-webkit-scrollbar, #propOutput::-webkit-scrollbar, #xpathOutput::-webkit-scrollbar {
      width: 8px;
      background: #222;
    }
    #sidebar::-webkit-scrollbar-thumb, #treeContainer::-webkit-scrollbar-thumb, #propTable::-webkit-scrollbar-thumb, #propOutput::-webkit-scrollbar-thumb, #xpathOutput::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }
  </style>
</head>
<body class="flex flex-col h-screen font-sans">
  <!-- Header -->
  <header class="bg-gray-800 text-white p-4 flex items-center justify-between">
    <h1 class="text-lg font-semibold">Appium / Generic XML Bounds Viewer</h1>
    <div class="flex gap-2">
      <label class="block"><input id="imgInput" type="file" accept="image/*" class="hidden" />
        <span class="inline-block text-center cursor-pointer bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700">Select Screenshot (JPG/PNG)</span></label>
      <label class="block"><input id="xmlInput" type="file" accept="text/xml,.xml" class="hidden" />
        <span class="inline-block text-center cursor-pointer bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700">Select UI XML</span></label>
    </div>
  </header>

  <main class="flex flex-1 overflow-hidden">
    <!-- Sidebar -->
    <aside id="sidebar" class="sidebar bg-gray-900 text-gray-100 p-4 border-r border-gray-800 space-y-4 overflow-y-auto" style="width: 24rem; min-width: 16rem; max-width: 40vw;">
      <div class="sidebar-drag" id="sidebarDrag"></div>
      <!-- Status -->
      <div class="space-y-1 text-xs">
        <div id="statusImg" class="flex items-center gap-1 text-gray-600"><span>üìÑ Screenshot:</span><span data-state="empty" class="font-medium">Not loaded</span></div>
        <div id="statusXml" class="flex items-center gap-1 text-gray-600"><span>üóÇÔ∏è XML:</span><span data-state="empty" class="font-medium">Not loaded</span></div>
        <div id="statusElements" class="flex items-center gap-1 text-gray-600 hidden"><span>üß© Elements:</span><span id="elementCount" class="font-medium">0</span></div>
      </div>

      <!-- Hierarchy -->
      <div class="flex flex-col">
        <h2 class="font-semibold mb-1">Hierarchy</h2>
        <div id="treeContainer" class="border rounded bg-white h-52 overflow-auto text-xs leading-5 py-1"></div>
      </div>

      <!-- Properties panel -->
      <div id="propPanelWrapper" class="flex flex-col" style="height: 16rem; min-height: 8rem;">
        <div class="flex justify-between items-center mb-1">
          <h2 class="font-semibold">Properties</h2>
          <div class="text-xs text-gray-500">Drag bottom to resize</div>
        </div>
        <div class="border rounded bg-white flex-1 flex flex-col overflow-hidden">
          <div class="overflow-auto flex-1" id="propTable">
            <table class="w-full text-xs">
              <thead class="bg-gray-100 sticky top-0">
                <tr>
                  <th class="text-left p-1 border-b">Name</th>
                  <th class="text-left p-1 border-b">Value</th>
                  <th class="w-8 border-b"></th>
                </tr>
              </thead>
              <tbody id="propOutput" class="font-mono"></tbody>
            </table>
          </div>
          <div class="h-2 bg-gray-100 border-t cursor-row-resize hover:bg-blue-100" id="propResizeHandle"></div>
        </div>
      </div>

      <!-- XPath -->
      <div class="space-y-2">
        <h2 class="font-semibold mb-1">Selected XPath</h2>
        <div>
          <div class="text-xs text-gray-400 mb-1">Shortest Unique XPath</div>
          <div class="relative">
            <textarea id="xpathOutputShort" readonly class="w-full h-16 p-2 border rounded bg-white text-xs font-mono resize-y"></textarea>
            <button onclick="copyToClipboard('xpathOutputShort')" class="absolute right-2 top-2 text-gray-500 hover:text-blue-600" title="Copy to clipboard">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
              </svg>
            </button>
          </div>
        </div>
        <div>
          <div class="text-xs text-gray-400 mb-1">Full XPath</div>
          <div class="relative">
            <textarea id="xpathOutputFull" readonly class="w-full h-16 p-2 border rounded bg-white text-xs font-mono resize-y"></textarea>
            <button onclick="copyToClipboard('xpathOutputFull')" class="absolute right-2 top-2 text-gray-500 hover:text-blue-600" title="Copy to clipboard">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </aside>

    <!-- Viewer -->
    <section id="viewer" class="relative flex-1 bg-black overflow-auto flex items-center justify-center">
      <div id="screenWrapper" class="relative">
        <img id="screenshot" alt="Screenshot" class="select-none" />
        <div id="overlayContainer" class="absolute inset-0"></div>
      </div>
    </section>
  </main>

<script>
/* ===== Element refs ===== */
const imgInput      = document.getElementById('imgInput');
const xmlInput      = document.getElementById('xmlInput');
const screenshotImg = document.getElementById('screenshot');
const overlay       = document.getElementById('overlayContainer');
const dropZone      = document.getElementById('dropZone');
const treeContainer = document.getElementById('treeContainer');
const propOutput    = document.getElementById('propOutput');
const statusImg     = document.querySelector('#statusImg [data-state]');
const statusXml     = document.querySelector('#statusXml [data-state]');
const statusElems   = document.getElementById('statusElements');
const elemCount     = document.getElementById('elementCount');
const propWrapper   = document.getElementById('propPanelWrapper');  // new reference

let xmlDoc = null;
const xpToOverlay = new Map();
const xpToTree    = new Map();
const xpToElem    = new Map();
let currentElement = null;

/* ===== Helpers ===== */
let lastImgFileName = '';
let lastXmlFileName = '';
function setStatus(el, state, ok='Loaded ‚úî', fileName='') {
  el.dataset.state = state;
  let msg = state==='ok' ? ok : state==='error' ? 'Error' : 'Not loaded';
  if (state==='ok' && fileName) msg += ` (${fileName})`;
  el.textContent = msg;
  el.classList.toggle('text-green-600', state==='ok');
  el.classList.toggle('text-red-600',   state==='error');
  el.classList.toggle('text-gray-600',  state!=='ok');
}

/* ===== Drag & Drop ===== */
function processFiles(files){Array.from(files).forEach(f=>{if(f.type.startsWith('image/')) loadImage(f); else if(f.name.endsWith('.xml')) loadXml(f);} );}
// Make whole screen a drop target
['dragenter','dragover'].forEach(eType=>document.body.addEventListener(eType,e=>{e.preventDefault();document.body.classList.add('bg-gray-200');}));
['dragleave','drop'].forEach(eType=>document.body.addEventListener(eType,e=>{e.preventDefault();if(eType==='drop') processFiles(e.dataTransfer.files);document.body.classList.remove('bg-gray-200');}));

/* ===== File pickers ===== */
document.querySelectorAll('#imgInput').forEach(input => {
  input.addEventListener('change', e => {
    if (e.target.files && e.target.files[0]) loadImage(e.target.files[0]);
  });
});
document.querySelectorAll('#xmlInput').forEach(input => {
  input.addEventListener('change', e => {
    if (e.target.files && e.target.files[0]) loadXml(e.target.files[0]);
  });
});

/* ===== Image ===== */
function loadImage(file){
  lastImgFileName = file.name;
  const r=new FileReader();
  r.onload=e=>screenshotImg.src=e.target.result;
  r.readAsDataURL(file);
  setStatus(statusImg,'ok','Loaded ‚úî', file.name);
}
screenshotImg.onload=()=>{resizeOverlay();renderOverlays();};
window.addEventListener('resize',()=>{if(screenshotImg.src){resizeOverlay();renderOverlays();}});
function resizeOverlay() {
  // Get the wrapper and image natural size
  const wrapper = document.getElementById('screenWrapper');
  const naturalWidth = screenshotImg.naturalWidth;
  const naturalHeight = screenshotImg.naturalHeight;
  const wrapperWidth = wrapper.offsetWidth;
  const wrapperHeight = wrapper.offsetHeight;
  // Calculate scale to fit both width and height (object-fit: contain)
  const scale = Math.min(wrapperWidth / naturalWidth, wrapperHeight / naturalHeight);
  // Calculate displayed image size
  const displayWidth = naturalWidth * scale;
  const displayHeight = naturalHeight * scale;
  // Set image size explicitly
  screenshotImg.style.width = `${displayWidth}px`;
  screenshotImg.style.height = `${displayHeight}px`;
  // Set overlay size to match image
  overlay.style.width = `${displayWidth}px`;
  overlay.style.height = `${displayHeight}px`;
}

/* ===== XML ===== */
function loadXml(file){
  lastXmlFileName = file.name;
  const r=new FileReader();
  r.onload=e=>{
    try{
      xmlDoc=new DOMParser().parseFromString(e.target.result,'application/xml');
      setStatus(statusXml,'ok','Loaded ‚úî', file.name);
      buildTree();
      renderOverlays();
    }catch(err){
      console.error(err);
      setStatus(statusXml,'error');
    }
  };
  r.readAsText(file);
}

/* ===== Tree ===== */
function buildTree(){treeContainer.innerHTML='';xpToTree.clear();if(!xmlDoc) return;treeContainer.appendChild(branch(xmlDoc.documentElement));}
function branch(el){const wrapper=document.createElement('div');const row=document.createElement('div');row.className='tree-row';const kids=[...el.children];const hasKids=kids.length>0;const caret=document.createElement('span');caret.textContent=hasKids?'‚ñº':'‚Ä¢';caret.className=hasKids?'text-gray-500':'text-gray-400';row.appendChild(caret);
const xp=getXP(el);
const label=document.createElement('span');label.textContent=labelOf(el);label.className='label';label.dataset.xp=xp;row.appendChild(label);
wrapper.appendChild(row);
row.addEventListener('click',e=>{e.stopPropagation();select(xp);});
if(hasKids){const ul=document.createElement('ul');kids.forEach(c=>ul.appendChild(branch(c)));wrapper.appendChild(ul);caret.addEventListener('click',e=>{e.stopPropagation();ul.classList.toggle('hidden');caret.textContent=ul.classList.contains('hidden')?'‚ñ∂':'‚ñº';});}
xpToTree.set(xp,label);return wrapper;}
function labelOf(el){return el.getAttribute('resource-id')||el.getAttribute('content-desc')||el.getAttribute('text')||el.tagName;}

/* ===== Overlays ===== */
function renderOverlays() {
  overlay.innerHTML = '';
  xpToOverlay.clear();
  xpToElem.clear();
  if (!xmlDoc || !screenshotImg.complete) return;
  
  // Get displayed image size and scale
  const wrapper = document.getElementById('screenWrapper');
  const naturalWidth = screenshotImg.naturalWidth;
  const naturalHeight = screenshotImg.naturalHeight;
  const wrapperWidth = wrapper.clientWidth;
  const wrapperHeight = wrapper.clientHeight;
  const scale = Math.min(wrapperWidth / naturalWidth, wrapperHeight / naturalHeight);
  
  // Get all elements with bounds and calculate their areas and depths
  const nodes = [];
  const allElements = xmlDoc.querySelectorAll('[bounds]');
  
  // First pass: collect all elements and their bounds
  allElements.forEach(node => {
    const bounds = node.getAttribute('bounds');
    const [x1, y1, x2, y2] = bounds.match(/\d+/g).map(Number);
    const area = (x2 - x1) * (y2 - y1);
    const depth = getXP(node).split('/').length;
    nodes.push({ 
      node, 
      area, 
      depth, 
      bounds: {x1, y1, x2, y2},
      xp: getXP(node)
    });
  });
  
  // Function to check if element a contains element b
  function contains(a, b) { 
    return a.bounds.x1 <= b.bounds.x1 && 
           a.bounds.y1 <= b.bounds.y1 && 
           a.bounds.x2 >= b.bounds.x2 && 
           a.bounds.y2 >= b.bounds.y2;
  }
  
  // Function to calculate how many elements contain this one
  function getContainmentLevel(node) { 
    return nodes.filter(n => n !== node && contains(n, node)).length;
  }
  
  // Sort by: 
  // 1. Number of elements that contain this one (more contained = higher z-index)
  // 2. Area (smaller first)
  // 3. Depth in the tree (deeper first)
  nodes.sort((a, b) => { 
    const aContainers = getContainmentLevel(a); 
    const bContainers = getContainmentLevel(b); 
    
    if (aContainers !== bContainers) { 
      return aContainers - bContainers; 
    }
    
    if (a.area !== b.area) { 
      return a.area - b.area; 
    }
    
    return b.depth - a.depth; 
  });
  
  elemCount.textContent = nodes.length;
  statusElems.classList.toggle('hidden', !nodes.length);
  
  // Create a z-index counter to ensure proper stacking
  let zIndex = 1; 
  
  // Render all nodes in the calculated order
  for (const {node, xp, bounds} of nodes) { 
    const {x1, y1, x2, y2} = bounds; 
    
    const box = document.createElement('div'); 
    box.className = 'element-box absolute'; 
    
    Object.assign(box.style, { 
      left: `${x1 * scale}px`, 
      top: `${y1 * scale}px`, 
      width: `${(x2 - x1) * scale}px`, 
      height: `${(y2 - y1) * scale}px`, 
      zIndex: zIndex++ // Increment z-index for each element
    }); 
    
    box.dataset.xp = xp; 
    box.addEventListener('click', e => { 
      e.stopPropagation(); 
      select(xp); 
      // Scroll hierarchy view to selected tree element
      const label = xpToTree.get(xp); 
      if (label) { 
        label.scrollIntoView({block: 'center', behavior: 'smooth'}); 
      } 
    }); 
    
    overlay.appendChild(box); 
    xpToOverlay.set(xp, box); 
    xpToElem.set(xp, node); 
  }
}

/* ===== XPath util ===== */
function getXP(el){const seg=[];let cur=el;while(cur&&cur.nodeType===1){let i=1;let sib=cur.previousElementSibling;while(sib){if(sib.tagName===cur.tagName)i++;sib=sib.previousElementSibling;}seg.unshift(`${cur.tagName}[${i}]`);cur=cur.parentElement;}return '/'+seg.join('/');}

function getShortestUniqueXPath(el) {
  if (!el || el.nodeType !== 1) return '';
  
  // Try to find the most specific unique selector
  const paths = [];
  let current = el;
  
  while (current && current.nodeType === 1) {
    let tag = current.tagName;
    let path = tag;
    
    // First, try to find a unique ID or resource-id
    const id = current.getAttribute('resource-id') || current.getAttribute('id');
    if (id) {
      path = `${tag}[@resource-id='${id}']`;
      paths.unshift(path);
      break;
    }
    
    // Then try other unique attributes
    const attrs = Array.from(current.attributes);
    const uniqueAttr = attrs.find(attr => {
      // Skip common attributes that might not be unique
      if (['bounds', 'index', 'checkable', 'checked', 'clickable', 'enabled', 
           'focusable', 'focused', 'scrollable', 'long-clickable', 'password',
           'selected', 'class', 'package', 'content-desc', 'text', 'resource-id', 'id'].includes(attr.name)) {
        return false;
      }
      
      // Only consider attributes with values
      if (!attr.value || attr.value.trim() === '') return false;
      
      const selector = `${tag}[@${attr.name}='${escapeXPathString(attr.value)}']`;
      try {
        return document.evaluate(
          `count(//${selector}) = 1`,
          document,
          null,
          XPathResult.BOOLEAN_TYPE,
          null
        ).booleanValue;
      } catch (e) {
        return false;
      }
    });
    
    if (uniqueAttr) {
      path = `${tag}[@${uniqueAttr.name}='${escapeXPathString(uniqueAttr.value)}']`;
      paths.unshift(path);
      break;
    }
    
    // Try content-desc and text as last resort
    const contentDesc = current.getAttribute('content-desc');
    const text = current.getAttribute('text');
    
    if (contentDesc) {
      const selector = `${tag}[@content-desc='${escapeXPathString(contentDesc)}']`;
      try {
        if (document.evaluate(`count(//${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
          paths.unshift(selector);
          break;
        }
      } catch (e) {}
    }
    
    if (text) {
      const selector = `${tag}[@text='${escapeXPathString(text)}']`;
      try {
        if (document.evaluate(`count(//${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
          paths.unshift(selector);
          break;
        }
      } catch (e) {}
    }
    
    // If no unique attribute found, use index
    let index = 1;
    let sibling = current.previousElementSibling;
    while (sibling) {
      if (sibling.tagName === tag) index++;
      sibling = sibling.previousElementSibling;
    }
    
    paths.unshift(`${tag}[${index}]`);
    current = current.parentElement;
  }
  
  return '/' + paths.join('/');
}

// Helper function to escape XPath string literals
function escapeXPathString(str) {
  if (str === null || str === undefined) return '';
  return String(str).replace(/'/g, '"');
}

function enhanceXPath(attrName, attrValue) {
  if (!currentElement) return;
  
  // Get current shortest XPath
  let xpath = document.getElementById('xpathOutputShort').value;
  
  // If the attribute is already in the XPath, don't add it again
  if (xpath.includes(`@${attrName}=`)) {
    return;
  }
  
  // Add the attribute to the XPath
  if (xpath.includes('@')) {
    // If there are already attributes, add this one with AND
    xpath = xpath.replace(/\]$/, ` and @${attrName}='${attrValue}']`);
  } else {
    // Otherwise, add the attribute condition
    xpath = xpath.replace(/(\[.*?\])?$/, `[@${attrName}='${attrValue}']`);
  }
  
  // Update the XPath display
  document.getElementById('xpathOutputShort').value = xpath;
  
  // Highlight the updated XPath briefly
  const xpathEl = document.getElementById('xpathOutputShort');
  xpathEl.classList.add('bg-yellow-100');
  setTimeout(() => xpathEl.classList.remove('bg-yellow-100'), 1000);
}

function copyToClipboard(elementId) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  element.select();
  document.execCommand('copy');
  
  // Show feedback using a tooltip instead of placeholder
  const tooltip = document.createElement('div');
  tooltip.textContent = 'Copied!';
  tooltip.className = 'absolute bg-black text-white text-xs px-2 py-1 rounded -top-8 right-0 whitespace-nowrap';
  
  const container = element.parentElement;
  container.style.position = 'relative';
  container.appendChild(tooltip);
  
  setTimeout(() => {
    tooltip.remove();
    element.blur();
  }, 1000);
}

/* ===== Selection sync ===== */
function clearSel(){
  document.querySelectorAll('.selected-box').forEach(b=>b.classList.remove('selected-box'));
  document.querySelectorAll('.selected-tree').forEach(l=>l.classList.remove('selected-tree'));
  propOutput.innerHTML = '';
  document.getElementById('xpathOutputFull').value = '';
  document.getElementById('xpathOutputShort').value = '';
  currentElement = null;
}
function select(xp) {
  clearSel();
  const element = xpToElem.get(xp);
  if (!element) return;
  
  // Update selection in the tree view
  const label = xpToTree.get(xp);
  if (label) {
    label.classList.add('selected-tree');
    // Scroll the selected element into view in the hierarchy
    label.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
  
  // Update the overlay box
  const box = xpToOverlay.get(xp);
  if (box) {
    box.classList.add('selected-box');
    // Scroll overlay box into view (centered)
    const overlayRect = overlay.getBoundingClientRect();
    const boxRect = box.getBoundingClientRect();
    const viewer = document.getElementById('viewer');
    // Only scroll if box is outside visible area
    if (boxRect.top < overlayRect.top || boxRect.bottom > overlayRect.bottom || 
        boxRect.left < overlayRect.left || boxRect.right > overlayRect.right) {
      // Center the box in the viewer
      const scrollX = boxRect.left + boxRect.width/2 - overlayRect.left - viewer.clientWidth/2;
      const scrollY = boxRect.top + boxRect.height/2 - overlayRect.top - viewer.clientHeight/2;
      viewer.scrollBy({left: scrollX, top: scrollY, behavior: 'smooth'});
    }
  }
  
  // Update XPath outputs
  currentElement = element;
  document.getElementById('xpathOutputFull').value  = getXP(element);
  document.getElementById('xpathOutputShort').value = getShortestUniqueXPath(element);
  updatePropertiesTable(element);
}

function updatePropertiesTable(element) {
  propOutput.innerHTML = '';
  
  if (!element) return;
  
  // Add all attributes as properties
  const attrs = element.attributes;
  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];
    if (attr.name === 'bounds') continue; // Skip bounds as they're shown in the UI
    
    const row = document.createElement('tr');
    row.className = 'hover:bg-gray-100 border-b';
    
    const nameCell = document.createElement('td');
    nameCell.className = 'p-1 break-all';
    nameCell.textContent = attr.name;
    
    const valueCell = document.createElement('td');
    valueCell.className = 'p-1 break-all';
    valueCell.textContent = attr.value || '';
    
    const actionCell = document.createElement('td');
    actionCell.className = 'p-1 text-center';
    
    const enhanceBtn = document.createElement('button');
    enhanceBtn.className = 'text-blue-500 hover:text-blue-700';
    enhanceBtn.title = 'Add to XPath';
    enhanceBtn.innerHTML = 'üîç';
    enhanceBtn.onclick = (e) => {
      e.stopPropagation();
      enhanceXPath(attr.name, attr.value);
    };
    
    actionCell.appendChild(enhanceBtn);
    row.appendChild(nameCell);
    row.appendChild(valueCell);
    row.appendChild(actionCell);
    propOutput.appendChild(row);
  }
}
  // Initialize properties table if it doesn't exist
  let propTable = document.getElementById('propTable');
  if (!propTable) {
    propTable = document.createElement('div');
    propTable.id = 'propTable';
    propTable.className = 'w-full h-40 overflow-auto border rounded bg-white text-xs font-mono';
    propOutput.parentNode.insertBefore(propTable, propOutput.nextSibling);
  }
function searchByAttr(attr, value) {
  if (!xmlDoc) return;
  try {
    const xp = `//*[@${attr}='${value.replace(/'/g, "&#39;")}']`;
    const result = xmlDoc.evaluate(xp, xmlDoc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
    if (result.singleNodeValue) {
      const xpath = getXP(result.singleNodeValue);
      select(xpath);
    }
  } catch (e) {
    console.error('Error in searchByAttr:', e);
  }
}

/* ===== Resizable Elements ===== */
// Properties panel vertical resizing (matches textarea behaviour)
const propResizeHandle = document.getElementById('propResizeHandle');
let isResizingProps = false;
let startY, startHeight;

propResizeHandle.addEventListener('mousedown', (e) => {
  isResizingProps = true;
  startY = e.clientY;
  startHeight = propWrapper.offsetHeight;
  document.documentElement.style.cursor = 'row-resize';
  document.documentElement.style.userSelect = 'none';
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isResizingProps) return;
  const newHeight = startHeight + e.clientY - startY;
  if (newHeight > 80) { // Minimum height (similar to textareas)
    propWrapper.style.height = `${newHeight}px`;
  }
  e.preventDefault();
});

document.addEventListener('mouseup', () => {
  if (isResizingProps) {
    isResizingProps = false;
    document.documentElement.style.cursor = '';
    document.documentElement.style.userSelect = '';
  }
});

// Sidebar drag resize
const sidebar = document.getElementById('sidebar');
const dragHandle = document.getElementById('sidebarDrag');
let isDraggingSidebar = false;
let sidebarWidth = sidebar.offsetWidth;
function getScrollbarWidth() {
  // Create a temporary div to measure scrollbar width
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll';
  outer.style.width = '100px';
  document.body.appendChild(outer);
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const width = outer.offsetWidth - inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  return width;
}
dragHandle.addEventListener('mousedown', function(e) {
  e.preventDefault();
  isDraggingSidebar = true;
  document.body.style.cursor = 'ew-resize';
  let startX = e.clientX;
  let startWidth = sidebar.offsetWidth;
  function onMove(ev) {
    let scrollbarW = getScrollbarWidth();
    let newWidth = Math.max(240, Math.min(window.innerWidth * 0.4, startWidth + (ev.clientX - startX)));
    sidebar.style.width = newWidth + 'px';
    sidebarWidth = newWidth;
    dragHandle.style.right = (sidebar.scrollHeight > sidebar.clientHeight ? -5 - scrollbarW : -5) + 'px';
    resizeOverlay(); // update image/overlay size on sidebar resize
  }
  function onUp() {
    isDraggingSidebar = false;
    document.body.style.cursor = '';
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp);
    resizeOverlay(); // ensure overlay/image size is correct after drag
  }
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
});
// Make the entire right edge of sidebar draggable
sidebar.addEventListener('mousemove', function(e) {
  let scrollbarW = getScrollbarWidth();
  let dragArea = sidebar.getBoundingClientRect().right + (sidebar.scrollHeight > sidebar.clientHeight ? scrollbarW : 0);
  if (Math.abs(e.clientX - dragArea) < 12) {
    sidebar.style.cursor = 'ew-resize';
  } else if (!isDraggingSidebar) {
    sidebar.style.cursor = '';
  }
});
sidebar.addEventListener('mousedown', function(e) {
  let scrollbarW = getScrollbarWidth();
  let dragArea = sidebar.getBoundingClientRect().right + (sidebar.scrollHeight > sidebar.clientHeight ? scrollbarW : 0);
  if (Math.abs(e.clientX - dragArea) < 12) {
    dragHandle.dispatchEvent(new MouseEvent('mousedown', e));
  }
});
// Responsive sidebar: keep width on grow/shrink
window.addEventListener('resize', () => {
  if (sidebarWidth) {
    sidebar.style.width = sidebarWidth + 'px';
    let scrollbarW = getScrollbarWidth();
    dragHandle.style.right = (sidebar.scrollHeight > sidebar.clientHeight ? -5 - scrollbarW : -5) + 'px';
  }
  if(screenshotImg.src){
    resizeOverlay();
    renderOverlays();
  }
});
</script>
</body>
</html>
