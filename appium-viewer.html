<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Universal XML‚ÄëBounds Viewer</title>
  <!-- Tailwind for styling (demo) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Screenshot always fully visible (fits height & width) */
    #screenWrapper,
    #screenshot {
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
    }

    /* Overlay boxes */
    .element-box {
      border: 2px solid rgba(16, 196, 16, 0.5);
      background: rgba(16, 196, 16, 0.01); /* 1% transparency */
      transition: all 0.2s ease;
      pointer-events: auto;
    }
    .element-box:hover {
      border-color: rgba(0, 192, 255, 0.85);
      background: rgba(0, 192, 255, 0.10);
    }
    .selected-box {
      border-color: rgb(239 68 68) !important;
      background: rgba(239, 68, 68, 0.16) !important;
      z-index: 90 !important;
    }
    /* XPath match highlighting */
    .xpath-match {
      border: 2px solid rgba(34, 211, 238, 0.8) !important;
      background: rgba(34, 211, 238, 0.2) !important;
      z-index: 80 !important;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.4); }
      70% { box-shadow: 0 0 0 6px rgba(34, 211, 238, 0); }
      100% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0); }
    }

    /* Tree styles */
    #treeContainer ul {
      list-style: none;
      margin: 0;
      padding: 0 0 0 0.5rem; /* indent children */
    }
    .tree-row {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      line-height: 1.25rem;
      cursor: pointer;
      white-space: nowrap;
    }
    .tree-row:hover span.label {
      color: rgb(37 99 235);
    }
    .selected-tree {
      color: rgb(239 68 68) !important;
      font-weight: 600;
    }

    /* Resizable sidebar */
    .resize-x {
      resize: horizontal;
      overflow: auto;
    }

    /* Resizable sidebar - drag handle */
    .sidebar {
      position: relative;
      background: #1a202c;
      color: #e5e7eb;
      border-right: 2px solid #222;
    }
    .sidebar-drag {
      position: absolute;
      top: 0;
      right: -5px;
      width: 12px;
      height: 100%;
      cursor: ew-resize;
      z-index: 10;
      background: rgba(59,130,246,0.18); /* brighter and easier to grab */
      border-radius: 3px;
      transition: background 120ms;
    }
    .sidebar-drag:hover {
      background: rgba(59,130,246,0.32);
    }
    /* Dark theme tweaks for sidebar */
    #sidebar h2 { color: #fff; }
    #sidebar .border { border-color: #333; }
    #sidebar .bg-white { background: #222; color: #e5e7eb; }
    #sidebar .text-xs { color: #cbd5e1; }
    #sidebar .font-mono { color: #a3e635; }
    #sidebar .rounded { border-radius: 0.375rem; }
    #sidebar .border-gray-300 { border-color: #333; }
    #sidebar .border { border-color: #333; }
    #sidebar .bg-gray-100 { background: #1a202c; }
    #sidebar .text-gray-600 { color: #a1a1aa; }
    #sidebar .text-gray-400 { color: #a1a1aa; }
    #sidebar .text-gray-500 { color: #a1a1aa; }
    #sidebar .text-green-600 { color: #22c55e; }
    #sidebar .text-red-600 { color: #ef4444; }
    #sidebar .text-blue-600 { color: #2563eb; }
    #sidebar .hover\:bg-blue-700:hover { background: #1e40af; }
    #sidebar .bg-blue-600 { background: #2563eb; }
    #sidebar .bg-blue-100 { background: #1e293b; color: #60a5fa; }
    #sidebar .hover\:bg-blue-300:hover { background: #2563eb; color: #fff; }
    /* Dark scrollbars */
    #sidebar, #treeContainer, #propTable, #propOutput, #xpathOutput {
      scrollbar-width: thin;
      scrollbar-color: #333 #222;
    }
    #sidebar::-webkit-scrollbar, #treeContainer::-webkit-scrollbar, #propTable::-webkit-scrollbar, #propOutput::-webkit-scrollbar, #xpathOutput::-webkit-scrollbar {
      width: 8px;
      background: #222;
    }
    #sidebar::-webkit-scrollbar-thumb, #treeContainer::-webkit-scrollbar-thumb, #propTable::-webkit-scrollbar-thumb, #propOutput::-webkit-scrollbar-thumb, #xpathOutput::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }
  </style>
</head>
<body class="flex flex-col h-screen font-sans">
  <!-- Header -->
  <header class="bg-gray-800 text-white p-4 flex items-center justify-between">
    <h1 class="text-lg font-semibold">Appium / Generic XML Bounds Viewer</h1>
    <div class="flex gap-2">
      <label class="block"><input id="imgInput" type="file" accept="image/*" class="hidden" />
        <span class="inline-block text-center cursor-pointer bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700">Select Screenshot (JPG/PNG)</span></label>
      <label class="block"><input id="xmlInput" type="file" accept="text/xml,.xml" class="hidden" />
        <span class="inline-block text-center cursor-pointer bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700">Select UI XML</span></label>
    </div>
  </header>

  <main class="flex flex-1 overflow-hidden">
    <!-- Sidebar -->
    <aside id="sidebar" class="sidebar bg-gray-900 text-gray-100 p-4 border-r border-gray-800 space-y-4 overflow-y-auto" style="width: 24rem; min-width: 16rem; max-width: 40vw;">
      <div class="sidebar-drag" id="sidebarDrag"></div>
      <!-- Status -->
      <div class="space-y-1 text-xs">
        <div id="statusImg" class="flex items-center gap-1 text-gray-600"><span>üìÑ Screenshot:</span><span data-state="empty" class="font-medium">Not loaded</span></div>
        <div id="statusXml" class="flex items-center gap-1 text-gray-600"><span>üóÇÔ∏è XML:</span><span data-state="empty" class="font-medium">Not loaded</span></div>
        <div id="statusElements" class="flex items-center gap-1 text-gray-600 hidden"><span>üß© Elements:</span><span id="elementCount" class="font-medium">0</span></div>
      </div>

      <!-- Hierarchy -->
      <div class="flex flex-col">
        <h2 class="font-semibold mb-1">Hierarchy</h2>
        <div id="treeContainer" class="border rounded bg-white h-52 overflow-auto text-xs leading-5 py-1"></div>
      </div>

      <!-- Properties panel -->
      <div id="propPanelWrapper" class="flex flex-col" style="height: 16rem; min-height: 8rem;">
        <div class="flex justify-between items-center mb-1">
          <h2 class="font-semibold">Properties</h2>
          <div class="text-xs text-gray-500">Drag bottom to resize</div>
        </div>
        <div class="border rounded bg-white flex-1 flex flex-col overflow-hidden">
          <div class="overflow-auto flex-1" id="propTable">
            <table class="w-full text-xs">
              <thead class="bg-gray-100 sticky top-0">
                <tr>
                  <th class="text-left p-1 border-b">Name</th>
                  <th class="text-left p-1 border-b">Value</th>
                  <th class="w-8 border-b"></th>
                </tr>
              </thead>
              <tbody id="propOutput" class="font-mono"></tbody>
            </table>
          </div>
          <div class="h-2 bg-gray-100 border-t cursor-row-resize hover:bg-blue-100" id="propResizeHandle"></div>
        </div>
      </div>

      <!-- XPath -->
      <div class="space-y-2">
        <h2 class="font-semibold mb-1">Selected XPath</h2>
        <div>
          <div class="text-xs text-gray-400 mb-1">XPath Selector</div>
          <div class="flex flex-col gap-2 mb-4">
            <div class="flex items-center gap-2">
              <select id="xpathSelector" class="flex-1 p-1.5 border rounded text-xs bg-gray-700 text-gray-100 border-gray-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500" onchange="updateXPathDisplay()">
                <option value="" class="bg-gray-800">Select XPath option...</option>
              </select>
              <button onclick="copySelectedXPath()" class="p-1.5 bg-gray-600 rounded hover:bg-gray-500 text-gray-200" title="Copy XPath to clipboard">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                </svg>
              </button>
            </div>
            <div class="relative">
              <textarea id="xpathDisplay" readonly rows="3" class="w-full p-2 border rounded text-xs font-mono bg-gray-700 text-gray-100 border-gray-600 resize-y min-h-[60px] focus:border-blue-500 focus:ring-1 focus:ring-blue-500" placeholder="Selected XPath will appear here"></textarea>
              <button onclick="copyXPathDisplay()" class="absolute right-1 top-1 p-1 text-gray-400 hover:text-blue-400" title="Copy XPath">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                </svg>
              </button>
            </div>
          </div>
          
          <!-- XPath Tester -->
          <div class="mt-4">
            <h3 class="font-semibold text-sm mb-2">XPath Tester</h3>
            <div class="relative">
              <div class="flex items-center gap-2 mb-2">
                <input type="text" id="xpathTesterInput" placeholder="Enter XPath to test" class="flex-1 p-1.5 border rounded text-xs bg-gray-700 text-gray-100 border-gray-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500" />
                <button onclick="testXPath()" class="p-1.5 bg-blue-600 rounded hover:bg-blue-700 text-white text-xs">
                  Test XPath
                </button>
                <button onclick="clearXPathTest()" class="p-1.5 bg-gray-600 rounded hover:bg-gray-500 text-white text-xs">
                  Clear
                </button>
              </div>
              <div id="xpathTestResults" class="text-xs text-gray-400 mb-2">
                <span id="xpathMatchCount">0</span> elements matched
              </div>
            </div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Viewer -->
    <section id="viewer" class="relative flex-1 bg-black overflow-auto flex items-center justify-center">
      <div id="screenWrapper" class="relative">
        <img id="screenshot" alt="Screenshot" class="select-none" />
        <div id="overlayContainer" class="absolute inset-0"></div>
      </div>
    </section>
  </main>

<script>
/* ===== Element refs ===== */
const imgInput      = document.getElementById('imgInput');
const xmlInput      = document.getElementById('xmlInput');
const screenshotImg = document.getElementById('screenshot');
const overlay       = document.getElementById('overlayContainer');
const dropZone      = document.getElementById('dropZone');
const treeContainer = document.getElementById('treeContainer');
const propOutput    = document.getElementById('propOutput');
const statusImg     = document.querySelector('#statusImg [data-state]');
const statusXml     = document.querySelector('#statusXml [data-state]');
const statusElems   = document.getElementById('statusElements');
const elemCount     = document.getElementById('elementCount');
const propWrapper   = document.getElementById('propPanelWrapper');  // new reference

let xmlDoc = null;
const xpToOverlay = new Map();
const xpToTree    = new Map();
const xpToElem    = new Map();
let currentElement = null;

/* ===== Helpers ===== */
let lastImgFileName = '';
let lastXmlFileName = '';
function setStatus(el, state, ok='Loaded ‚úî', fileName='') {
  el.dataset.state = state;
  let msg = state==='ok' ? ok : state==='error' ? 'Error' : 'Not loaded';
  if (state==='ok' && fileName) msg += ` (${fileName})`;
  el.textContent = msg;
  el.classList.toggle('text-green-600', state==='ok');
  el.classList.toggle('text-red-600',   state==='error');
  el.classList.toggle('text-gray-600',  state!=='ok');
}

/* ===== Drag & Drop ===== */
function processFiles(files){Array.from(files).forEach(f=>{if(f.type.startsWith('image/')) loadImage(f); else if(f.name.endsWith('.xml')) loadXml(f);} );}
// Make whole screen a drop target
['dragenter','dragover'].forEach(eType=>document.body.addEventListener(eType,e=>{e.preventDefault();document.body.classList.add('bg-gray-200');}));
['dragleave','drop'].forEach(eType=>document.body.addEventListener(eType,e=>{e.preventDefault();if(eType==='drop') processFiles(e.dataTransfer.files);document.body.classList.remove('bg-gray-200');}));

/* ===== File pickers ===== */
document.querySelectorAll('#imgInput').forEach(input => {
  input.addEventListener('change', e => {
    if (e.target.files && e.target.files[0]) loadImage(e.target.files[0]);
  });
});
document.querySelectorAll('#xmlInput').forEach(input => {
  input.addEventListener('change', e => {
    if (e.target.files && e.target.files[0]) loadXml(e.target.files[0]);
  });
});

/* ===== Image ===== */
function loadImage(file){
  lastImgFileName = file.name;
  const r=new FileReader();
  r.onload=e=>screenshotImg.src=e.target.result;
  r.readAsDataURL(file);
  setStatus(statusImg,'ok','Loaded ‚úî', file.name);
}
screenshotImg.onload=()=>{resizeOverlay();renderOverlays();};
window.addEventListener('resize',()=>{if(screenshotImg.src){resizeOverlay();renderOverlays();}});
function resizeOverlay() {
  // Get the wrapper and image natural size
  const wrapper = document.getElementById('screenWrapper');
  const naturalWidth = screenshotImg.naturalWidth;
  const naturalHeight = screenshotImg.naturalHeight;
  const wrapperWidth = wrapper.offsetWidth;
  const wrapperHeight = wrapper.offsetHeight;
  // Calculate scale to fit both width and height (object-fit: contain)
  const scale = Math.min(wrapperWidth / naturalWidth, wrapperHeight / naturalHeight);
  // Calculate displayed image size
  const displayWidth = naturalWidth * scale;
  const displayHeight = naturalHeight * scale;
  // Set image size explicitly
  screenshotImg.style.width = `${displayWidth}px`;
  screenshotImg.style.height = `${displayHeight}px`;
  // Set overlay size to match image
  overlay.style.width = `${displayWidth}px`;
  overlay.style.height = `${displayHeight}px`;
}

/* ===== XML ===== */
function loadXml(file){
  lastXmlFileName = file.name;
  const r=new FileReader();
  r.onload=e=>{
    try{
      xmlDoc=new DOMParser().parseFromString(e.target.result,'application/xml');
      setStatus(statusXml,'ok','Loaded ‚úî', file.name);
      buildTree();
      renderOverlays();
    }catch(err){
      console.error(err);
      setStatus(statusXml,'error');
    }
  };
  r.readAsText(file);
}

/* ===== Tree ===== */
function buildTree(){treeContainer.innerHTML='';xpToTree.clear();if(!xmlDoc) return;treeContainer.appendChild(branch(xmlDoc.documentElement));}
function branch(el){const wrapper=document.createElement('div');const row=document.createElement('div');row.className='tree-row';const kids=[...el.children];const hasKids=kids.length>0;const caret=document.createElement('span');caret.textContent=hasKids?'‚ñº':'‚Ä¢';caret.className=hasKids?'text-gray-500':'text-gray-400';row.appendChild(caret);
const xp=getXP(el);
const label=document.createElement('span');label.textContent=labelOf(el);label.className='label';label.dataset.xp=xp;row.appendChild(label);
wrapper.appendChild(row);
row.addEventListener('click',e=>{e.stopPropagation();select(xp);});
if(hasKids){const ul=document.createElement('ul');kids.forEach(c=>ul.appendChild(branch(c)));wrapper.appendChild(ul);caret.addEventListener('click',e=>{e.stopPropagation();ul.classList.toggle('hidden');caret.textContent=ul.classList.contains('hidden')?'‚ñ∂':'‚ñº';});}
xpToTree.set(xp,label);return wrapper;}
function labelOf(el){return el.getAttribute('resource-id')||el.getAttribute('content-desc')||el.getAttribute('text')||el.tagName;}

/* ===== Overlays ===== */
function renderOverlays() {
  overlay.innerHTML = '';
  xpToOverlay.clear();
  xpToElem.clear();
  if (!xmlDoc || !screenshotImg.complete) return;
  
  // Get displayed image size and scale
  const wrapper = document.getElementById('screenWrapper');
  const naturalWidth = screenshotImg.naturalWidth;
  const naturalHeight = screenshotImg.naturalHeight;
  const wrapperWidth = wrapper.clientWidth;
  const wrapperHeight = wrapper.clientHeight;
  const scale = Math.min(wrapperWidth / naturalWidth, wrapperHeight / naturalHeight);
  
  // Get all elements with bounds and calculate their areas and depths
  const nodes = [];
  const allElements = xmlDoc.querySelectorAll('[bounds]');
  
  // First pass: collect all elements and their bounds
  allElements.forEach(node => {
    const bounds = node.getAttribute('bounds');
    const [x1, y1, x2, y2] = bounds.match(/\d+/g).map(Number);
    const area = (x2 - x1) * (y2 - y1);
    const depth = getXP(node).split('/').length;
    nodes.push({ 
      node, 
      area, 
      depth, 
      bounds: {x1, y1, x2, y2},
      xp: getXP(node)
    });
  });
  
  // Function to check if element a contains element b
  function contains(a, b) { 
    return a.bounds.x1 <= b.bounds.x1 && 
           a.bounds.y1 <= b.bounds.y1 && 
           a.bounds.x2 >= b.bounds.x2 && 
           a.bounds.y2 >= b.bounds.y2;
  }
  
  // Function to calculate how many elements contain this one
  function getContainmentLevel(node) { 
    return nodes.filter(n => n !== node && contains(n, node)).length;
  }
  
  // Sort by: 
  // 1. Number of elements that contain this one (more contained = higher z-index)
  // 2. Area (smaller first)
  // 3. Depth in the tree (deeper first)
  nodes.sort((a, b) => { 
    const aContainers = getContainmentLevel(a); 
    const bContainers = getContainmentLevel(b); 
    
    if (aContainers !== bContainers) { 
      return aContainers - bContainers; 
    }
    
    if (a.area !== b.area) { 
      return a.area - b.area; 
    }
    
    return b.depth - a.depth; 
  });
  
  elemCount.textContent = nodes.length;
  statusElems.classList.toggle('hidden', !nodes.length);
  
  // Create a z-index counter to ensure proper stacking
  let zIndex = 1; 
  
  // Render all nodes in the calculated order
  for (const {node, xp, bounds} of nodes) { 
    const {x1, y1, x2, y2} = bounds; 
    
    const box = document.createElement('div'); 
    box.className = 'element-box absolute'; 
    
    const isSelected = currentElement && getXP(currentElement) === xp;
    
    Object.assign(box.style, { 
      left: `${x1 * scale}px`, 
      top: `${y1 * scale}px`, 
      width: `${(x2 - x1) * scale}px`, 
      height: `${(y2 - y1) * scale}px`, 
      zIndex: zIndex++, // Increment z-index for each element
      pointerEvents: isSelected ? 'none' : 'auto' // Disable pointer events for selected element
    }); 
    
    if (isSelected) {
      box.classList.add('selected-box');
    }
    
    box.dataset.xp = xp; 
    box.addEventListener('click', e => { 
      e.stopPropagation(); 
      select(xp); 
      // Scroll hierarchy view to selected tree element
      const label = xpToTree.get(xp); 
      if (label) { 
        label.scrollIntoView({block: 'center', behavior: 'smooth'}); 
      } 
    }); 
    
    overlay.appendChild(box); 
    xpToOverlay.set(xp, box); 
    xpToElem.set(xp, node); 
  }
}

/* ===== XPath util ===== */
function getXP(el) {
  const seg = [];
  let cur = el;
  while (cur && cur.nodeType === 1) {
    let i = 1;
    let sib = cur.previousElementSibling;
    while (sib) {
      if (sib.tagName === cur.tagName) i++;
      sib = sib.previousElementSibling;
    }
    seg.unshift(`${cur.tagName}[${i}]`);
    cur = cur.parentElement;
  }
  return '/' + seg.join('/');
}

// Check if an XPath returns exactly one element
function isXPathUnique(xpath) {
  try {
    const result = document.evaluate(
      `count(${xpath})`,
      xmlDoc,
      null,
      XPathResult.NUMBER_TYPE,
      null
    );
    return result.numberValue === 1;
  } catch (e) {
    console.warn('Error checking XPath uniqueness:', e);
    return false;
  }
}

// Generate multiple unique XPaths for an element with priority on resource-id, text, content-desc
function generateXPathOptions(element) {
  if (!element) return [];
  
  const options = [];
  const addedXPaths = new Set();
  
  // Helper to add XPath if unique
  function addXPathIfUnique(xpath, type, priority) {
    if (!xpath || addedXPaths.has(xpath) || !isXPathUnique(xpath)) return false;
    
    options.push({
      type: type,
      value: xpath,
      priority: priority
    });
    addedXPaths.add(xpath);
    return true;
  }
  
  // 1. Try resource-id (highest priority)
  const resourceId = element.getAttribute('resource-id');
  if (resourceId) {
    const xpath = `//${element.tagName}[@resource-id='${escapeXPathString(resourceId)}']`;
    addXPathIfUnique(xpath, 'Resource ID', 1);
  }
  
  // 2. Try text content
  const text = element.getAttribute('text');
  if (text && text.trim() !== '') {
    const xpath = `//${element.tagName}[@text='${escapeXPathString(text)}']`;
    addXPathIfUnique(xpath, 'Text', 2);
  }
  
  // 3. Try content description
  const contentDesc = element.getAttribute('content-desc');
  if (contentDesc) {
    const xpath = `//${element.tagName}[@content-desc='${escapeXPathString(contentDesc)}']`;
    addXPathIfUnique(xpath, 'Content Description', 3);
  }
  
  // 4. Try other unique attributes
  const attrs = element.attributes;
  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];
    const name = attr.name;
    
    // Skip common non-unique attributes
    if (['resource-id', 'text', 'content-desc', 'class', 'package', 'checkable', 
         'checked', 'clickable', 'enabled', 'focusable', 'focused', 'scrollable', 
         'long-clickable', 'password', 'selected', 'bounds', 'index'].includes(name)) {
      continue;
    }
    
    const value = attr.value;
    if (value && value.trim() !== '') {
      const xpath = `//${element.tagName}[@${name}='${escapeXPathString(value)}']`;
      addXPathIfUnique(xpath, `@${name}`, 4);
    }
  }
  
  // 5. Add full XPath as fallback
  const fullXPath = getXP(element);
  if (!addedXPaths.has(fullXPath)) {
    options.push({
      type: 'Full XPath',
      value: fullXPath,
      priority: 100
    });
    addedXPaths.add(fullXPath);
  }
  
  // Sort by priority (lower number = higher priority)
  options.sort((a, b) => a.priority - b.priority);
  
  // Limit to 3 best options
  return options.slice(0, 3);
}

function getXPathByUniqueAttribute(element) {
  const attrs = Array.from(element.attributes);
  const uniqueAttr = attrs.find(attr => {
    if (!attr.value || attr.value.trim() === '') return false;
    if (['bounds', 'index', 'checkable', 'checked', 'clickable', 'enabled', 
         'focusable', 'focused', 'scrollable', 'long-clickable', 'password',
         'selected', 'class', 'package'].includes(attr.name)) {
      return false;
    }
    
    const selector = `${element.tagName}[@${attr.name}='${escapeXPathString(attr.value)}']`;
    try {
      return document.evaluate(
        `count(//${selector}) = 1`,
        document,
        null,
        XPathResult.BOOLEAN_TYPE,
        null
      ).booleanValue;
    } catch (e) {
      return false;
    }
  });
  
  if (uniqueAttr) {
    return `//${element.tagName}[@${uniqueAttr.name}='${escapeXPathString(uniqueAttr.value)}']`;
  }
  return null;
}

function getXPathByContent(element) {
  const contentDesc = element.getAttribute('content-desc');
  const text = element.getAttribute('text');
  
  if (contentDesc) {
    const selector = `//${element.tagName}[@content-desc='${escapeXPathString(contentDesc)}']`;
    try {
      if (document.evaluate(`count(${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
        return selector;
      }
    } catch (e) {}
  }
  
  if (text) {
    const selector = `//${element.tagName}[@text='${escapeXPathString(text)}']`;
    try {
      if (document.evaluate(`count(${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
        return selector;
      }
    } catch (e) {}
  }
  
  return null;
}

function getAlternativeXPath(element) {
  // Try to find a parent with an ID or unique attribute
  let current = element;
  let levels = 0;
  const maxLevels = 3; // Limit the depth to prevent too long XPaths
  
  while (current && current.nodeType === 1 && levels < maxLevels) {
    const id = current.getAttribute('resource-id') || current.getAttribute('id');
    if (id) {
      return `//${current.tagName}[@resource-id='${id}']` + 
             (levels > 0 ? `//${element.tagName}` : '');
    }
    
    const uniqueAttr = Array.from(current.attributes).find(attr => {
      if (!attr.value || attr.value.trim() === '') return false;
      return !['bounds', 'index', 'checkable', 'checked', 'clickable', 'enabled', 
               'focusable', 'focused', 'scrollable', 'long-clickable', 'password',
               'selected', 'class', 'package', 'content-desc', 'text', 'resource-id', 'id'].includes(attr.name);
    });
    
    if (uniqueAttr) {
      return `//${current.tagName}[@${uniqueAttr.name}='${escapeXPathString(uniqueAttr.value)}']` + 
             (levels > 0 ? `//${element.tagName}` : '');
    }
    
    current = current.parentElement;
    levels++;
  }
  
  return null;
}

// Copy the currently selected XPath to clipboard
function copySelectedXPath() {
  const selector = document.getElementById('xpathSelector');
  const xpath = selector.value;
  if (xpath) {
    navigator.clipboard.writeText(xpath).then(() => {
      // Show tooltip or feedback
      const button = document.querySelector('#xpathSelector + div + button');
      const originalTitle = button.getAttribute('title');
      button.setAttribute('title', 'Copied!');
      setTimeout(() => {
        button.setAttribute('title', originalTitle);
      }, 2000);
    });
  }
}


// Update the XPath selector dropdown with new options
function updateXPathSelector(element) {
  const selector = document.getElementById('xpathSelector');
  const xpOptions = generateXPathOptions(element);
  
  // Clear existing options
  selector.innerHTML = '';
  
  // Add default option
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select XPath option...';
  selector.appendChild(defaultOption);
  
  // Add generated options
  xpOptions.forEach(opt => {
    const option = document.createElement('option');
    option.value = opt.value;
    option.textContent = `${opt.type} (${opt.value.length} chars)`;
    option.dataset.type = opt.type;
    option.dataset.xpath = opt.value; // Store full XPath in data attribute
    selector.appendChild(option);
  });
  
  // Select the first option by default if available
  if (xpOptions.length > 0) {
    selector.selectedIndex = 1; // Skip the default option
    updateXPathDisplay();
  }
}

// Update the XPath display input with the currently selected XPath
function updateXPathDisplay() {
  const selector = document.getElementById('xpathSelector');
  const display = document.getElementById('xpathDisplay');
  
  if (selector.selectedIndex > 0) {
    const selectedOption = selector.options[selector.selectedIndex];
    const fullXPath = selectedOption.dataset.xpath || selectedOption.value;
    display.value = fullXPath;
  } else {
    display.value = '';
  }
}

// Copy the currently displayed XPath to clipboard
function copyXPathDisplay() {
  const display = document.getElementById('xpathDisplay');
  if (display.value) {
    navigator.clipboard.writeText(display.value).then(() => {
      const button = event.currentTarget;
      const originalTitle = button.getAttribute('title');
      button.setAttribute('title', 'Copied!');
      button.classList.remove('text-gray-400');
      button.classList.add('text-green-500');
      
      setTimeout(() => {
        button.setAttribute('title', originalTitle);
        button.classList.remove('text-green-500');
        button.classList.add('text-gray-400');
      }, 2000);
    });
  }
}

// Copy the selected XPath to clipboard
function copySelectedXPath() {
  const display = document.getElementById('xpathDisplay');
  if (display.value) {
    navigator.clipboard.writeText(display.value).then(() => {
      const button = document.querySelector('#xpathSelector + button');
      if (button) {
        const originalTitle = button.getAttribute('title');
        button.setAttribute('title', 'Copied!');
        
        // Create a temporary element to show the copied tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'absolute -top-8 left-1/2 transform -translate-x-1/2 bg-black text-white text-xs px-2 py-1 rounded';
        tooltip.textContent = 'Copied!';
        button.parentNode.appendChild(tooltip);
        
        setTimeout(() => {
          button.setAttribute('title', originalTitle);
          if (tooltip.parentNode) {
            tooltip.parentNode.removeChild(tooltip);
          }
        }, 1000);
      }
    });
  }
}

// Test an XPath expression and highlight matching elements
function testXPath() {
  // Clear previous test results but keep the input value
  const xpathInput = document.getElementById('xpathTesterInput');
  const xpath = xpathInput.value.trim();
  
  if (!xpath) {
    showStatus('Please enter an XPath expression to test', 'error');
    return;
  }
  
  // Clear only the highlights, not the input
  clearXPathTest();
  
  try {
    // Find all matching elements
    const result = document.evaluate(
      xpath,
      xmlDoc,
      null,
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
      null
    );
    
    const count = result.snapshotLength;
    const matchCountElement = document.getElementById('xpathMatchCount');
    matchCountElement.textContent = count;
    
    if (count === 0) {
      showStatus('No elements found matching the XPath', 'warning');
      return;
    }
    
    // Store the XPath that was tested
    xpathInput.dataset.lastTestedXPath = xpath;
    
    // Highlight all matching elements
    const overlay = document.getElementById('overlayContainer');
    const matches = [];
    
    for (let i = 0; i < count; i++) {
      const element = result.snapshotItem(i);
      if (!element) continue;
      
      const elementXPath = getXP(element);
      if (!elementXPath) continue;
      
      const box = xpToOverlay.get(elementXPath);
      if (box) {
        // Store the match for later reference
        matches.push({
          element: element,
          xpath: elementXPath,
          box: box
        });
      }
    }
    
    // Now highlight all valid matches
    matches.forEach((match, index) => {
      match.box.classList.add('xpath-match');
      
      // Scroll the first match into view
      if (index === 0) {
        match.box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    });
    
    const statusMessage = `Found ${matches.length} matching element${matches.length !== 1 ? 's' : ''}`;
    showStatus(statusMessage, 'success');
    
  } catch (e) {
    console.error('XPath error:', e);
    showStatus(`XPath error: ${e.message}`, 'error');
    document.getElementById('xpathMatchCount').textContent = '0';
  }
}

// Clear XPath test highlights
function clearXPathTest() {
  // Remove all xpath-match highlights
  document.querySelectorAll('.xpath-match').forEach(el => {
    el.classList.remove('xpath-match');
  });
  
  // Reset match count
  document.getElementById('xpathMatchCount').textContent = '0';
  
  // Note: We don't clear the input value here anymore
  // to allow for multiple tests of the same XPath
}

function getShortestUniqueXPath(el) {
  if (!el || el.nodeType !== 1) return '';
  
  // Try to find the most specific unique selector
  const paths = [];
  let current = el;
  
  while (current && current.nodeType === 1) {
    let tag = current.tagName;
    let path = tag;
    
    // First, try to find a unique ID or resource-id
    const id = current.getAttribute('resource-id') || current.getAttribute('id');
    if (id) {
      path = `${tag}[@resource-id='${id}']`;
      paths.unshift(path);
      break;
    }
    
    // Then try other unique attributes
    const attrs = Array.from(current.attributes);
    const uniqueAttr = attrs.find(attr => {
      // Skip common attributes that might not be unique
      if (['bounds', 'index', 'checkable', 'checked', 'clickable', 'enabled', 
           'focusable', 'focused', 'scrollable', 'long-clickable', 'password',
           'selected', 'class', 'package', 'content-desc', 'text', 'resource-id', 'id'].includes(attr.name)) {
        return false;
      }
      
      // Only consider attributes with values
      if (!attr.value || attr.value.trim() === '') return false;
      
      const selector = `${tag}[@${attr.name}='${escapeXPathString(attr.value)}']`;
      try {
        return document.evaluate(
          `count(//${selector}) = 1`,
          document,
          null,
          XPathResult.BOOLEAN_TYPE,
          null
        ).booleanValue;
      } catch (e) {
        return false;
      }
    });
    
    if (uniqueAttr) {
      path = `${tag}[@${uniqueAttr.name}='${escapeXPathString(uniqueAttr.value)}']`;
      paths.unshift(path);
      break;
    }
    
    // Try content-desc and text as last resort
    const contentDesc = current.getAttribute('content-desc');
    const text = current.getAttribute('text');
    
    if (contentDesc) {
      const selector = `${tag}[@content-desc='${escapeXPathString(contentDesc)}']`;
      try {
        if (document.evaluate(`count(//${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
          paths.unshift(selector);
          break;
        }
      } catch (e) {}
    }
    
    if (text) {
      const selector = `${tag}[@text='${escapeXPathString(text)}']`;
      try {
        if (document.evaluate(`count(//${selector}) = 1`, document, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
          paths.unshift(selector);
          break;
        }
      } catch (e) {}
    }
    
    // If no unique attribute found, use index
    let index = 1;
    let sibling = current.previousElementSibling;
    while (sibling) {
      if (sibling.tagName === tag) index++;
      sibling = sibling.previousElementSibling;
    }
    
    paths.unshift(`${tag}[${index}]`);
    current = current.parentElement;
  }
  
  return '/' + paths.join('/');
}

// Helper function to escape XPath string literals
function escapeXPathString(str) {
  if (str === null || str === undefined) return '';
  return String(str).replace(/'/g, '"');
}

function enhanceXPath(attrName, attrValue) {
  if (!currentElement) return;
  
  // Get the current XPath from the display or tester input
  let currentXPath = document.getElementById('xpathDisplay').value.trim();
  
  // If there's no current XPath in display, check the tester input
  if (!currentXPath) {
    currentXPath = document.getElementById('xpathTesterInput').value.trim();
  }
  
  // If still no XPath, use the full XPath of the current element
  if (!currentXPath) {
    currentXPath = getXP(currentElement);
  }
  
  // Create a new XPath by appending the condition
  let newXPath;
  const escapedValue = escapeXPathString(attrValue);
  
  // Check if the XPath already has conditions
  const hasExistingConditions = currentXPath.includes('[') && currentXPath.endsWith(']');
  
  if (hasExistingConditions) {
    // Check if this exact attribute condition already exists
    const attrPattern = new RegExp(`@${attrName}=['"]${escapedValue}['"]`);
    if (currentXPath.match(attrPattern)) {
      showStatus(`@${attrName}='${attrValue}' already exists in XPath`, 'info');
      return;
    }
    
    // Insert before the closing bracket
    newXPath = currentXPath.replace(']', ` and @${attrName}='${escapedValue}']`);
  } else {
    // Add new condition
    newXPath = `${currentXPath}[@${attrName}='${escapedValue}']`;
  }
  
  // Update the XPath display
  const xpathDisplay = document.getElementById('xpathDisplay');
  xpathDisplay.value = newXPath;
  
  // Also update the tester input
  document.getElementById('xpathTesterInput').value = newXPath;
  
  // Update the selector dropdown
  updateXPathSelectorWithCustomXPath(currentElement, newXPath, `By ${attrName}`);
  
  // Select the new XPath in the dropdown
  const xpathSelector = document.getElementById('xpathSelector');
  for (let i = 0; i < xpathSelector.options.length; i++) {
    if (xpathSelector.options[i].value === newXPath) {
      xpathSelector.selectedIndex = i;
      break;
    }
  }
  
  // Show success message
  showStatus(`Added @${attrName}='${attrValue}' to XPath`, 'success');
  
  // Test the new XPath
  testXPath();
}

function copyToClipboard(elementId) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  element.select();
  document.execCommand('copy');
  
  // Show feedback using a tooltip instead of placeholder
  const tooltip = document.createElement('div');
  tooltip.textContent = 'Copied!';
  tooltip.className = 'absolute bg-black text-white text-xs px-2 py-1 rounded -top-8 right-0 whitespace-nowrap';
  
  const container = element.parentElement;
  container.style.position = 'relative';
  container.appendChild(tooltip);
  
  setTimeout(() => {
    tooltip.remove();
    element.blur();
  }, 1000);
}

/* ===== Selection sync ===== */
function clearSel(){
  document.querySelectorAll('.selected-box').forEach(b => b.classList.remove('selected-box'));
  document.querySelectorAll('.selected-tree').forEach(l => l.classList.remove('selected-tree'));
  
  // Clear properties table
  const propTable = document.getElementById('propTable');
  if (propTable) {
    propTable.innerHTML = '';
  }
  
  // Clear XPath selector
  const xpathSelector = document.getElementById('xpathSelector');
  if (xpathSelector) {
    xpathSelector.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Select XPath option...';
    xpathSelector.appendChild(defaultOption);
  }
  
  // Clear the current element and refresh overlays
  currentElement = null;
  if (overlay) {
    renderOverlays();
  }
}
function select(xp) {
  clearSel();
  const element = xpToElem.get(xp);
  if (!element) return;
  
  // Store the selected element
  currentElement = element;
  
  // Update selection in the tree view
  const label = xpToTree.get(xp);
  if (label) {
    label.classList.add('selected-tree');
    label.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
  
  // Re-render overlays to update pointer events
  renderOverlays();
  
  // Update the overlay box and scroll it into view
  const box = xpToOverlay.get(xp);
  if (box) {
    const overlayRect = overlay.getBoundingClientRect();
    const boxRect = box.getBoundingClientRect();
    const viewer = document.getElementById('viewer');
    if (boxRect.top < overlayRect.top || boxRect.bottom > overlayRect.bottom || 
        boxRect.left < overlayRect.left || boxRect.right > overlayRect.right) {
      const scrollX = boxRect.left + boxRect.width/2 - overlayRect.left - viewer.clientWidth/2;
      const scrollY = boxRect.top + boxRect.height/2 - overlayRect.top - viewer.clientHeight/2;
      viewer.scrollBy({left: scrollX, top: scrollY, behavior: 'smooth'});
    }
  }
  
  currentElement = element;
  
  // Update the XPath selector with new options
  updateXPathSelector(element);
  
  // Update properties table
  updatePropertiesTable(element);
}

function updatePropertiesTable(element) {
  // Initialize properties table if it doesn't exist
  let propTable = document.getElementById('propTable');
  if (!propTable) {
    propTable = document.createElement('div');
    propTable.id = 'propTable';
    propOutput.appendChild(propTable);
  }
  
  // Clear existing properties
  propTable.innerHTML = '';
  
  // Add all attributes as properties
  const attrs = element.attributes;
  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];
    const attrName = attr.name;
    const attrValue = attr.value;
    
    // Skip empty or internal attributes
    if (!attrName || !attrValue || attrName.startsWith('_') || 
        ['bounds', 'index'].includes(attrName)) {
      continue;
    }
    
    const propRow = document.createElement('div');
    propRow.className = 'flex items-center py-1 border-b border-gray-200';
    
    const propName = document.createElement('div');
    propName.className = 'w-1/3 text-xs text-gray-600 font-mono';
    propName.textContent = attrName;
    
    const propValue = document.createElement('div');
    propValue.className = 'w-2/3 text-xs font-mono truncate';
    propValue.textContent = attrValue;
    
    const propActions = document.createElement('div');
    propActions.className = 'flex items-center ml-2';
    
    // Add magnifying glass button to enhance XPath with this attribute
    const magnifyBtn = document.createElement('button');
    magnifyBtn.className = 'text-gray-400 hover:text-blue-600 p-1';
    magnifyBtn.title = 'Enhance XPath with this attribute';
    magnifyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>';
    magnifyBtn.onclick = (e) => {
      e.stopPropagation();
      enhanceXPath(attrName, attrValue);
    };
    
    // Add copy button
    const copyBtn = document.createElement('button');
    copyBtn.className = 'text-gray-400 hover:text-blue-600 p-1';
    copyBtn.title = 'Copy to clipboard';
    copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>';
    copyBtn.onclick = (e) => {
      e.stopPropagation();
      navigator.clipboard.writeText(attrValue).then(() => {
        const originalTitle = copyBtn.getAttribute('title');
        copyBtn.setAttribute('title', 'Copied!');
        setTimeout(() => {
          copyBtn.setAttribute('title', originalTitle);
        }, 2000);
      });
    };
    
    propActions.appendChild(magnifyBtn);
    propActions.appendChild(copyBtn);
    
    propRow.appendChild(propName);
    propRow.appendChild(propValue);
    propRow.appendChild(propActions);
    
    propTable.appendChild(propRow);
  }
  
  // Add a row for the element's XPath
  const xpathRow = document.createElement('div');
  xpathRow.className = 'flex items-center py-1 border-b border-gray-200';
  
  const xpathLabel = document.createElement('div');
  xpathLabel.className = 'w-1/3 text-xs text-gray-600 font-mono';
  xpathLabel.textContent = 'xpath';
  
  const xpathValue = document.createElement('div');
  xpathValue.className = 'w-2/3 text-xs font-mono truncate';
  xpathValue.textContent = getXP(element);
  
  const xpathActions = document.createElement('div');
  xpathActions.className = 'flex items-center ml-2';
  
  const xpathCopyBtn = document.createElement('button');
  xpathCopyBtn.className = 'text-gray-400 hover:text-blue-600 p-1';
  xpathCopyBtn.title = 'Copy to clipboard';
  xpathCopyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>';
  xpathCopyBtn.onclick = (e) => {
    e.stopPropagation();
    navigator.clipboard.writeText(getXP(element)).then(() => {
      const originalTitle = xpathCopyBtn.getAttribute('title');
      xpathCopyBtn.setAttribute('title', 'Copied!');
      setTimeout(() => {
        xpathCopyBtn.setAttribute('title', originalTitle);
      }, 2000);
    });
  };
  
  xpathActions.appendChild(xpathCopyBtn);
  
  xpathRow.appendChild(xpathLabel);
  xpathRow.appendChild(xpathValue);
  xpathRow.appendChild(xpathActions);
  
  propTable.appendChild(xpathRow);
}

// Helper function to update XPath selector with a custom XPath
function updateXPathSelectorWithCustomXPath(element, customXPath, label) {
  const selector = document.getElementById('xpathSelector');
  const xpOptions = generateXPathOptions(element);
  
  // Clear existing options
  selector.innerHTML = '';
  
  // Add default option
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select XPath option...';
  selector.appendChild(defaultOption);
  
  // Add custom XPath as first option
  const customOption = document.createElement('option');
  customOption.value = customXPath;
  customOption.textContent = label || 'Custom XPath';
  customOption.selected = true;
  selector.appendChild(customOption);
  
  // Add other options but avoid duplicates
  xpOptions.forEach(opt => {
    if (opt.value !== customXPath) {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.label;
      option.dataset.type = opt.type;
      selector.appendChild(option);
    }
  });
}

function searchByAttr(attr, value) {
  if (!xmlDoc) return;
  try {
    const xp = `//*[@${attr}='${value.replace(/'/g, "&#39;")}']`;
    const result = xmlDoc.evaluate(xp, xmlDoc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
    if (result.singleNodeValue) {
      const xpath = getXP(result.singleNodeValue);
      select(xpath);
    }
  } catch (e) {
    console.error('Error in searchByAttr:', e);
  }
}

/* ===== Resizable Elements ===== */
// Properties panel vertical resizing (matches textarea behaviour)
const propResizeHandle = document.getElementById('propResizeHandle');
let isResizingProps = false;
let startY, startHeight;

propResizeHandle.addEventListener('mousedown', (e) => {
  isResizingProps = true;
  startY = e.clientY;
  startHeight = propWrapper.offsetHeight;
  document.documentElement.style.cursor = 'row-resize';
  document.documentElement.style.userSelect = 'none';
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isResizingProps) return;
  const newHeight = startHeight + e.clientY - startY;
  if (newHeight > 80) { // Minimum height (similar to textareas)
    propWrapper.style.height = `${newHeight}px`;
  }
  e.preventDefault();
});

document.addEventListener('mouseup', () => {
  if (isResizingProps) {
    isResizingProps = false;
    document.documentElement.style.cursor = '';
    document.documentElement.style.userSelect = '';
  }
});

// Sidebar drag resize
const sidebar = document.getElementById('sidebar');
const dragHandle = document.getElementById('sidebarDrag');
let isDraggingSidebar = false;
let sidebarWidth = sidebar.offsetWidth;
function getScrollbarWidth() {
  // Create a temporary div to measure scrollbar width
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll';
  outer.style.width = '100px';
  document.body.appendChild(outer);
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const width = outer.offsetWidth - inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  return width;
}
dragHandle.addEventListener('mousedown', function(e) {
  e.preventDefault();
  isDraggingSidebar = true;
  document.body.style.cursor = 'ew-resize';
  let startX = e.clientX;
  let startWidth = sidebar.offsetWidth;
  function onMove(ev) {
    let scrollbarW = getScrollbarWidth();
    let newWidth = Math.max(240, Math.min(window.innerWidth * 0.4, startWidth + (ev.clientX - startX)));
    sidebar.style.width = newWidth + 'px';
    sidebarWidth = newWidth;
    dragHandle.style.right = (sidebar.scrollHeight > sidebar.clientHeight ? -5 - scrollbarW : -5) + 'px';
    resizeOverlay(); // update image/overlay size on sidebar resize
  }
  function onUp() {
    isDraggingSidebar = false;
    document.body.style.cursor = '';
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp);
    resizeOverlay(); // ensure overlay/image size is correct after drag
  }
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
});
// Make the entire right edge of sidebar draggable
sidebar.addEventListener('mousemove', function(e) {
  let scrollbarW = getScrollbarWidth();
  let dragArea = sidebar.getBoundingClientRect().right + (sidebar.scrollHeight > sidebar.clientHeight ? scrollbarW : 0);
  if (Math.abs(e.clientX - dragArea) < 12) {
    sidebar.style.cursor = 'ew-resize';
  } else if (!isDraggingSidebar) {
    sidebar.style.cursor = '';
  }
});
sidebar.addEventListener('mousedown', function(e) {
  let scrollbarW = getScrollbarWidth();
  let dragArea = sidebar.getBoundingClientRect().right + (sidebar.scrollHeight > sidebar.clientHeight ? scrollbarW : 0);
  if (Math.abs(e.clientX - dragArea) < 12) {
    dragHandle.dispatchEvent(new MouseEvent('mousedown', e));
  }
});
// Responsive sidebar: keep width on grow/shrink
window.addEventListener('resize', () => {
  if (sidebarWidth) {
    sidebar.style.width = sidebarWidth + 'px';
    let scrollbarW = getScrollbarWidth();
    dragHandle.style.right = (sidebar.scrollHeight > sidebar.clientHeight ? -5 - scrollbarW : -5) + 'px';
  }
  if(screenshotImg.src){
    resizeOverlay();
    renderOverlays();
  }
});
</script>
</body>
</html>
